// Prisma schema for MakeAnon - Email Masking Service

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// Available email domains for aliases
model Domain {
  id          String   @id @default(uuid())
  domain      String   @unique // e.g., "mask.example.com"
  description String?
  isActive    Boolean  @default(true)
  isDefault   Boolean  @default(false)
  isPublic    Boolean  @default(true) // Can be used by anyone

  // Stats
  aliasCount  Int      @default(0)

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  aliases     Alias[]

  @@index([isActive])
  @@index([isPublic])
  @@map("domains")
}

// Optional user accounts (for private alias management)
model User {
  id            String   @id @default(uuid())
  email         String   // Encrypted ciphertext (or plaintext for legacy)
  emailHash     String?  @unique // HMAC-SHA256 for lookups
  emailIv       String?
  emailSalt     String?
  emailAuthTag  String?
  isEmailEncrypted Boolean @default(false)
  password      String?  // Optional - only required for private aliases
  name          String?
  isActive      Boolean  @default(true)
  isAdmin       Boolean  @default(false)
  emailVerified Boolean  @default(false)

  // Limits
  maxAliases    Int      @default(100)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  aliases       Alias[]
  emailLogs     EmailLog[]

  @@index([emailHash])
  @@map("users")
}


// Email verification tokens
model VerificationToken {
  id          String   @id @default(uuid())
  email       String
  token       String   @unique
  type        String   // "email_verify", "alias_verify", "password_reset", "management"
  metadata    String?  // JSON string for additional data
  expiresAt   DateTime
  usedAt      DateTime?

  createdAt   DateTime @default(now())

  @@index([email])
  @@index([token])
  @@index([expiresAt])
  @@map("verification_tokens")
}

// Email aliases - can be public or private
model Alias {
  id            String   @id @default(uuid())
  alias         String   // The masked email prefix (e.g., "abc123")
  domainId      String
  domain        Domain   @relation(fields: [domainId], references: [id])
  fullAddress   String   @unique // Full alias email (e.g., "abc123@mask.example.com")

  // Destination (encrypted)
  // The real email is encrypted using AES-256-GCM with a key derived from MASTER_ENCRYPTION_KEY
  // These fields store the encrypted data - the plaintext is NEVER stored in the database
  destinationEmail    String   // Encrypted ciphertext (base64)
  destinationIv       String?  // Initialization vector (base64)
  destinationSalt     String?  // Salt for key derivation (base64)
  destinationAuthTag  String?  // GCM authentication tag (base64)
  isEncrypted         Boolean  @default(false) // Flag for migration - true if encrypted

  // Hash of the destination email for counting/lookups without exposing the plaintext
  // Uses SHA-256 with a pepper (MASTER_ENCRYPTION_KEY) so it can't be rainbow-tabled
  destinationHash     String?  // SHA-256 hash for lookups

  emailVerified    Boolean @default(false)

  // Metadata
  label         String?  // User-friendly label
  description   String?
  isActive      Boolean  @default(true)
  isPrivate     Boolean  @default(false) // Private aliases require auth to manage

  // Security - management token for public aliases
  managementToken String?  @unique

  // Statistics
  forwardCount    Int      @default(0)
  lastForwardAt   DateTime?
  blockedCount    Int      @default(0)

  // Tracking for auto-deletion
  disabledAt      DateTime? // When alias was disabled (for 30-day deletion)

  // Reply support - allows replying through the alias
  replyEnabled    Boolean  @default(false)
  replyPrefix     String?  @unique // Unique prefix for reply routing

  // Optional owner (for private aliases)
  userId        String?
  user          User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  expiresAt     DateTime? // Optional expiration

  emailLogs     EmailLog[]
  blockedSenders BlockedSender[]

  @@unique([alias, domainId])
  @@index([destinationHash])
  @@index([userId])
  @@index([alias])
  @@index([domainId])
  @@index([isActive])
  @@index([expiresAt])
  @@index([managementToken])
  @@map("aliases")
}


// Blocked senders per alias
model BlockedSender {
  id        String   @id @default(uuid())
  aliasId   String
  alias     Alias    @relation(fields: [aliasId], references: [id], onDelete: Cascade)

  email     String   // Blocked email address or pattern
  isPattern Boolean  @default(false) // If true, email is a regex pattern
  reason    String?

  createdAt DateTime @default(now())

  @@unique([aliasId, email])
  @@index([aliasId])
  @@map("blocked_senders")
}

// Email activity logs
model EmailLog {
  id          String   @id @default(uuid())

  // Email details
  fromEmail   String
  toAlias     String
  subject     String?
  messageId   String?

  // Size info
  sizeBytes   Int?

  // Status: received, forwarded, replied, failed, blocked, spam
  status      String   @default("received")
  error       String?

  // Processing time in ms
  processingTime Int?

  // Relations
  aliasId     String?
  alias       Alias?   @relation(fields: [aliasId], references: [id], onDelete: SetNull)

  userId      String?
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)

  createdAt   DateTime @default(now())

  @@index([aliasId])
  @@index([userId])
  @@index([createdAt])
  @@index([status])
  @@index([fromEmail])
  @@map("email_logs")
}

